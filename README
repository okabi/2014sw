実験用


* オブジェクトファイルとのリンク方法
  資料がゴミってるのでこっちの方法で
    nasm -f elf test.asm
    gcc -m32 -o program main.c test.asm

* makefile作ったから、
    make tc=test2.tc
  とかで一発で実行ファイル作れる

* 拡張
  x 外部関数参照が大丈夫かチェック
  o ビット演算子の追加
  o forの追加
  o continue、breakの追加(ループ内で使われていることを意味解析でチェックする)
  * 意味解析でエラー発生時に処理を停止する
  * インクリメント・デクリメントの追加
  * 剰余演算子の追加







* コード生成部で考慮する必要のあるもの
  * GLOBAL
    大域変数・関数を宣言する際に必要。
	GLOBAL label
    これにより、大域ラベルlabelが認識される。大域ラベル宣言前に必要な命令。

  * EXTERN
    他のモジュールで宣言されるラベルを参照するために必要。
        EXTERN label
	call label
    関数labelの呼び出しには、このように記述する必要がある。
    同じラベルに対して2回以上EXTERN指示した場合、2回め以降の指示は無視される。

  * レジスタRからの相対番地nは、[R+n][R-n][n+R]などで指示する。

  * COMMON
    大域データ領域へのメモリ割り当て(大域変数用)
	COMMON label n
    nバイトのメモリを大域データ領域に割り当て、そのアドレスをlabelとする。

  * 大域変数呼び出しは、labelではなく[label]と記述する。

  * ラベルのみの行があってもよい

  * ;以降はコメントとみなされる
    








* 意味解析部でいるもの
  * 意味解析ではエラーリカバリも行う
  * 違う深さレベルで変数宣言が既に行われている名前で変数を宣言しようとした場合、
    警告を出す（パラメータで宣言されている場合は特別なものを出す）。
    また、大域変数を宣言する際、レベル0で関数・未定義関数・大域変数に既に使われた名前が存在する場合、
    エラー（エラーリカバリを行う）。
  * まだ変数宣言されていない名前の変数を呼ぼうとした場合、エラーを出す（エラーリカバリを行う）。
  * 既に関数宣言された名前で関数を宣言しようとした場合、エラーを出す（エラーリカバリを行う）。
  * まだ関数宣言されていない名前の関数を呼ぼうとした場合、警告を出す（未定義関数）。
    その際、ブロックレベル0に未定義関数としてスタックの間にその関数を挿入する。
  * 関数の引数チェックを行う。
  * 木構造の表示の際、レベルと関数からの相対番地（レベル1以降）を表示する。相対番地の表示は、
    木構造の表示の際に行うべきらしい。
  * エラー・警告が起きた場合は何行目かを表示する。
  * エラーが起きた場合は木構造を表示しない。

  ・現在の深さレベル
  ・スタック
  ・オブジェクト構造体
	・名前
	・深さレベル
		・グローバル -> 0
		・関数の引数 -> 1
		・以降、{}の内部 -> 2以上
	・オブジェクト種類
		・VAR -> 変数
		・FUN -> 関数
		・UNDEFFUN -> 未定義関数
	・オフセット
		・関数の場合、引数の数を保存
		・それ以外の場合、未定義
　・スタック情報破棄関数
	・引数
		・破棄する深さレベル
	・返り値
		・なし
	・動作
		・}で同じ深さレベルの情報を破棄
　・スタック内検索関数（変数・関数参照用）
	・引数
		・検索する名前
		・検索するオブジェクト種類
	・返り値
		連想配列を返す。
		・level
			・-1     -> 無かった
			・ 0以上 -> レベル n にあった
		・size
			・関数検索の場合のみ、引数の数
	・動作
		・スタック配列内を検索し、適切な値を返す。
　・スタック挿入（pushではなく）関数（未定義関数呼び出し用）
	・引数
		連想配列を渡す。
		・name
			・挿入する未定義関数の名前
		・size
			・挿入する未定義関数の引数の数
	・返り値
		・なし
	・動作
		・レベル0の場所に未定義関数情報を挿入する・

・1つの文法規則の途中にアクションを書いても、各部分のresultはまだ出来ていない
　-> よって、関数宣言の際、とりあえず適当な名前とサイズで初期化しておき、スタックに積んでおく。
  -> 関数宣言の部分resultがすべて出た段階で、関数情報を上書きする。
  -> この場合、再帰関数がうまく処理できない（再帰された場合、関数名が'UNKNOWN'）。
  -> エラースタックを積んでおき、関数宣言の部分resultがすべて出た段階で、その関数名が宣言されなかった場合は未定義関数でスタックを積む